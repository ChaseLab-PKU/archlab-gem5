/*
 * Arch 2024 fall course code.
 * - This is a C++ code generating a graph for SPFA algorithm.
 * - This code is generated by Github Copilot.
 * - This program will generate a connected, directed and
 * positive-weighted graph, and store it in a file as a C-style struct.
 * It will also init helper structures, including distance array,
 * visited array, and the queue.
 */

#include "spfa.h"

#include <cstdlib>
#include <ctime>
#include <fstream>
#include <iostream>
#include <random>
#include <stack>
#include <unordered_set>

std::stack<int> st;
std::unordered_set<int> unvis;
std::unordered_set<int> leaves;

void treenize(int n, int s, Graph &g, std::mt19937 &gen,
              std::uniform_int_distribution<> &dis,
              std::uniform_int_distribution<> &dis_w) {
    st.push(s);
    for (int i = 0; i < n; i++) {
        unvis.insert(i);
        leaves.insert(i);
    }
    int edge_count = 0;
    unvis.erase(s);
    while (!st.empty()) {
        int u = st.top();
        if (leaves.find(u) != leaves.end()) {
            leaves.erase(u);
        }
        st.pop();
        // randomly pick a node from unvis
        int v = *std::next(unvis.begin(), dis(gen) % unvis.size());
        int w = 10000;
        g.edge[edge_count].to = v;
        g.edge[edge_count].w = w;
        g.edge[edge_count].next = g.head[u];
        g.head[u] = edge_count;
    }
    // Connect leaves to source as ring
    for (int u : leaves) {
        int w = 10000;
        g.edge[edge_count].to = s;
        g.edge[edge_count].w = w;
        g.edge[edge_count].next = g.head[u];
        g.head[u] = edge_count;
        edge_count++;
    }
}

// Generating the graph. Receiving the node number and edge number.
// Randomly choose two unconnected union sets, choose two random
// nodes from each set, and connect them with a random weight.
void generate(int n, int m, int s, Graph &g) {
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(0, n - 1);
    std::uniform_int_distribution<> dis_w(1, 1000);
    // Initialize the graph.
    for (int i = 0; i < n; i++) {
        g.head[i] = -1;
    }
    // Firstly connect source node to all other nodes in a tree.
    treenize(n, s, g, gen, dis, dis_w);
    // Then randomly connect the rest of the nodes.
    for (int i = 0; i < m - n + 1; i++) {
        int u = dis(gen);
        int v = dis(gen);
        if (u == v) {
            i--;
            continue;
        }
        int w = dis_w(gen);
        g.edge[i + n - 1].to = v;
        g.edge[i + n - 1].w = w;
        g.edge[i + n - 1].next = g.head[u];
        g.head[u] = i + n - 1;
    }
}

Graph g;

int main(int argc, char *argv[]) {
    if (argc != 4) {
        std::cout << "Usage: " << argv[0] << " <file_name> <n> <m>\n";
        return 1;
    }

    std::ofstream file(argv[1]);
    if (!file.is_open()) {
        std::cout << "Error: Unable to open file " << argv[1] << "\n";
        return 1;
    }

    int n = std::atoi(argv[2]);
    int m = std::atoi(argv[3]);
    file << "#include \"spfa.h\"\n";
    file << "#define N " << n << "\n";
    file << "#define M " << m << "\n";
    file << "#define S 0"
         << "\n";
    generate(n, m, 0, g);
    // Store the graph in the file as a C-style struct.
    file << "Graph G = {\n";
    file << "  .head = {";
    for (int i = 0; i < n; i++) {
        file << g.head[i];
        if (i != n - 1) file << ", ";
    }
    file << "},\n";
    file << "  .edge = {\n";
    for (int i = 0; i < m; i++) {
        file << "    { .to = " << g.edge[i].to << ", .w = " << g.edge[i].w
             << ", .next = " << g.edge[i].next << " }";
        if (i != m - 1) file << ",\n";
    }
    file << "\n  }\n};\n";
    // Init the helper structures
    file << "int DIS[N] = "
         << "{";
    for (int i = 0; i < n; i++) {
        file << "2147483647";
        if (i != n - 1) file << ", ";
    }
    file << "};\n";
    file << "int VIS[N] = {";
    for (int i = 0; i < n; i++) {
        file << "1";
        if (i != n - 1) file << ", ";
    }
    file << "};\n";
    file << "RingQueue Q;\n";
    file << "\n";
    file.close();

    return 0;
}
